# 오픈스택(클라우드 운영체제)

: 'VMware Workstation', 'Virtual Box'와 같이 가상머신을 제공하여 호스트 컴퓨터에서 다수의 운영체제를 동시에 실행 관리 가능하도록 지원하는 IaaS 형태의 플랫폼.

-> **오픈소스의 하이퍼바이저(Hypervisor)를 지원, 관리하는 서비스**

[오픈스택 개념 참고](https://blog.naver.com/love_tolty/220231856481)



## 0. 오픈스택 서비스 종류



<h3> 1) Nova

: 클라우드 IaaS 구축에 필요한 가상 컴퓨트 인스턴스들을 제어하고 관리하기 위한 서비스로, **오픈스택에서 가장 중요한 프로젝트**

\- 가상머신의 생성, 갱신, 삭제, 생명주기 관리 기능을 제공한다.

(※ AWS의 EC2와 호환된 API를 제공. 리눅스의 커널과 같은 역할 담당)



- Nova가 지원하는 하이퍼 바이저
  - Qemu와 KVM(커널을 기반으로 전가상화 방식을 지원하는 오픈 소스 하이퍼바이저)
  - Hyper-V와 Vmware, XenServer6.2

---

※ **Hypervisor** : 호스트 컴퓨터 1대에서 다수의 운영체제를 동시에 실행할 수 있도록 해주는 가상 플랫폼 기술. 여러 개의 OS가 단일 하드웨어 호스트를 공유할 수 있도록 하는 프로그램이며, 각 OS 는 호스트의 프로세서, 메모리 및 기타 자원들을 모두 스스로 나타낸다.

![img](https://blog.resellerclub.com/wp-content/uploads/2019/06/unnamed.png)

**1) 전가상화**(Full Vitrualization) : 하이퍼바이저를 이용해 호스트 서버 장치가 직접 가상화되어 가상 머신이 직접 장치를 사용할 수 있도록 하는 방식. 가상 머신들이 CPU를 직접 접근하기 때문에 부하가 많이 발생하고 성능 저하가 생기는 단점을 가지고 있음



![image-20191230134858262](https://user-images.githubusercontent.com/58682321/71606019-f00f6280-2bb0-11ea-84ee-91240b811eca.png)



**2) 반가상화**(Para Virtualization): 가상 머신이 호스트 서버의 CPU를 직접 접근하지 않고 하이퍼바이저에 위탁하여 작업을 처리하는 방식. 전가상화에 비해 퍼포먼스가 상대적으로 좋다는 장점이 있으나 가상머신으로 설치되는 OS가 하이퍼바이저에 대응하는 커널을 제공하지 못하면 사용할 수 없다는 단점을 가지고 있음



![image-20191230135104445](https://user-images.githubusercontent.com/58682321/71606022-f9003400-2bb0-11ea-806e-8c34f93f379f.png)

---







---

# 1. CentOS 기반 오픈스택 설치

## VMware workstation 기반 호스트 준비

#### 자동화 tool에 의한 설치



![image-20191230142543831](https://user-images.githubusercontent.com/58682321/71606024-00274200-2bb1-11ea-90ff-ee2da370d215.png)

![image-20191230172802744](https://user-images.githubusercontent.com/58682321/71606032-0b7a6d80-2bb1-11ea-9757-8cc129ffb1c9.png)

- 호스트 이름 : controller

  ![image-20191230172848542](https://user-images.githubusercontent.com/58682321/71606044-1c2ae380-2bb1-11ea-98a1-cfcfd136dcaf.png)

- Number of cores per processor : 2

  

- Disk File :  browse -> HPE>openstack 



- VM settings : cpu mode 변경

  ※ Virtual Intel VT-x/EPT or AMD-V/R VI : CPU, 메모리 가상 모듈 활성화

  

  #####  -> openstack에서 기본 Hypervisor로 KVM을 사용하며, KVM기반 VM을 시작하기 위해서 CPU 가상 모드를 반드시 활성화하여야 한다.

  

- CD/DVD : ISO file을 mapping 시켜 설치 준비 완료



- 홈 파티션의 경우 용량이 거의 필요 없기 때문에 2GiB로 설정
- / 파티션을 70 GiB로 늘려준다.

- 호스트 이름 : controller(이더넷 켬)

- Type : NAT
- Subnet IP : 10 . 0 . 0 , Subnet mask : 255 .255 .255 . 0





## 1.1 Controller Host에 OS 설치

**※ 설치 과정 PDF 참조**



### CentOS 설치

```shell
# ip a	
ip 주소 확인
# yum repolist	
인터넷 연결 확인
# yum update -y	
최신 버전으로 업데이트
```



### 1.2  선행 조건

**(※ 교재 73p 참조)**



- 네트워크 및 방화벽 조건(CentOS 서비스 최적화)

  ```shell
  #systemctl stop firewalld
  #systemctl disable firewalld
  #systemctl disable NetworkManager
  #systemctl stop NetworkManager
  ```



- SE Linux : port, 레이블? 개념정리

  ```shell
  # getenforce
  Enforcing	## 방화벽이 활성화되어 있다
  
  # setenforce 0
  # getenforce
  Permissive	## 방화벽을 제거
  ```

  \- 명령어로 바꾸는 것은 메모리에 저장되기 때문에 재부팅을 하게되면 방화벽이 다시 활성화 되어 있다. **이는 아래와 같이 vim 편집기로 해결 가능**

  ```shell
  # vi /etc/selinux/config
  
  SELINUX=disabled
  
  :wq!
  
  # 방화벽 제거를 유지하는 방법
  ```

  

- 하드웨어 정보 확인

  ```shell
  # egrep '(vmx|svm)' /proc/cpuinfo
  vmx는 인텔 기반, svm은 AMD 기반의 CPU를 의미
  
  # lscpu
  Virtualization: VT-x
  ```



## 1.3 설치 완료

- 호스트 정보 확인

  ```shell
  # cat /etc/centos-release
  ```

  



## 2. NTP 서버 설정

```shell
# yum install chrony -y
# vi /etc/chrony.conf

--------수정---------
# server0 ~
# server1 ~
# server2 ~
server3 ~
server 2.kr.pool.ntp.org iburs

server 127.127.1.0 	: local clock source(로컬 clock system 사용) --- 'Server'

allow 10.0.0.0/24  :  'Client'
--------------------
:wq!

# yum install -y ntpdate
# date
# grep server /etc/chrony.conf
변경 사항 확인

# ntpdate 2.kr.pool.ntp.org

# systemctl start chronyd
# systemctl enable chronyd
# chronyc sources

127.127.1.0 이 안보일 경우
# systemctl restart chronyd
```

* 컨트롤러 노드가 NTP 서버의 역할(정확한 시간을 제공하는 서버)을 수행하고 나머지 노드는 NTP 클라이언트로서 그 시간 정보를 서버로부터 가져와서 동기화를 각각 수행

- 외부로 부터 시간을 받아 서버와 클라이언트의 시간의 동기화를 수행한다. 이 후, 서버와 클라이언트 간의 시간 차이가 나는 것을 수정하는 작업을 진행한다.



```shell
# vi /etc/hosts

-------------
10.0.0.100 controller
10.0.0.101 compute1
-------------
:wq!

```

![image-20191230164531711](https://user-images.githubusercontent.com/58682321/71606051-2947d280-2bb1-11ea-9fff-13ef063aceab.png)



































---

## IP Class 개념

- IP Class의 경우 A, B, C Class로 나누어 Network ID와 Host ID로 구분한다.



![image-20191230150145924](https://user-images.githubusercontent.com/58682321/71606058-349afe00-2bb1-11ea-8437-5f2982a51888.png)



- 첫 번째 옥텟(Octet)으로 Class를 구분할 수 있다. (※ 옥텟은 2진수 8개(8bit)를 묶음으로 표현한 것)

| A Class |  B Class  |  C Class  |
| :-----: | :-------: | :-------: |
| 0 ~ 127 | 128 ~ 191 | 192 ~ 223 |



- ex) 192.168.1.1/24 ->  Network ID : 192.168.1 , /24(3byte) 즉, 앞에서 3번 째 자리까지 네트워크 아이디 라는 것을 알 수 있다. A Class 의 경우 10.0.0.1/8 로 나타낼 수 있음.

