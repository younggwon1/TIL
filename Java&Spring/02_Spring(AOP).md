# AOP(Aspect Oriented Programming)

> **AOP**는 애플리케이션 전체에 걸쳐 사용되는 기능을 재사용하도록 지원하는 것이다.
>
> AOP란 단어를 번역하면 **관점(관심) 지향 프로그래밍**이다. 쉽게 얘기하면 프로젝트 구조를 바라보는 관점을 바꿔보자는 이야기이다. 즉, 대상을 바라보는 방향을 바꿔보자라는 이야기이다.



- 어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고  그 관점을 기준으로 각각 모듈화하겠다는 것이다. 여기서 **모듈화**란 어떤 공통된 로직이나 기능을 하나의 단위로 묶는 것을 말한다.
- **핵심적인 관점** : 핵심 비즈니스 로직, **부가적인 관점** : 핵심 로직을 실행하기 위해서 행해지는 데이터베이스 연결, 로깅, 파일 입출력 등을 예로 들 수 있다.
- AOP에서 각 관점을 기준으로 로직을 모듈화한다는 것은 코드들을 부분적으로 나누어서 모듈화하겠다는 의미이다. 이때, 소스 코드상에서 **다른 부분에 계속 반복해서 사용하는 코드**들이 있는데 이것을 **Crosscutting Concerns**이라 부른다. 

![캡처](https://user-images.githubusercontent.com/42603919/78420880-41d2f780-768e-11ea-8389-9f49e3651306.PNG)

- 위와 같이 **Crosscutting Concerns**를 **Aspect로 모듈화하고 핵심적인 비즈니스 로직에서 분리하여 재사용하겠다는 것이 AOP의 취지**다.



#### AOP 주요 개념

- **Aspect** : 위에서 설명한 흩어진 관심사를 모듈화 한 것. 주로 부가기능을 모듈화함.
- **Target** : Aspect를 적용하는 곳 (클래스, 메서드 .. )
- **Advice** : 실질적으로 어떤 일을 해야할 지에 대한 것, 실질적인 부가기능을 담은 구현체
- **JointPoint** : Advice가 적용될 위치, 끼어들 수 있는 지점. 메서드 진입 지점, 생성자 호출 시점, 필드에서 값을 꺼내올 때 등 다양한 시점에 적용가능
- **PointCut** : JointPoint의 상세한 스펙을 정의한 것. 'A란 메서드의 진입 시점에 호출할 것'과 같이 더욱 구체적으로 Advice가 실행될 지점을 정할 수 있음
- **Proxy** : Target을 감싸서 Target의 요청을 대신 받아주는 Wrapping 오브젝드이다. 호출자에서 타겟을 호출하게 되면 타겟이 아닌 타겟을 감싸고 있는 프록시가 호출되어, 다텟 메소드 실행 전에 선처리, 타겟 메소드 실행 후, 후처리를 실행시키도록 구성되어 있다.

![캡처](https://user-images.githubusercontent.com/42603919/78423231-f45f8600-769f-11ea-8d33-dce62155c123.PNG)

- **Weaving** : Advice를 핵심 로직 코드에 적용하는 것을 weaving 이라고 한다.(분리한 관점을 여러 차례 모률에 삽입하는 것을 AOP에서는 위빙 (Weaving: 엮기)이라고 부른다.) 즉 공통 코드를 핵심 로직 코드에 삽입하는 것이 weaving이다.

  어드바이스를 핵심 로직 코드에 삽입하는 것을  Weaving이라고 한다.

  Aspect를 target 객체에 제공하여 새로운 프록시 객체를 생성하는 과정을 말한다.

  3가지 방식이 존재한다.

  - **Compile-time Weaving**
    Load-time에 대한 절차가 없어서 퍼포먼스 하락 없이 구성이 가능하다.
    Lombok과 같이 compile시 간섭하는 plugin들과 충돌이 발생함.
  - **Class Load-time Weaving**
    applicationContext에 로드된 객체들을 불러온 뒤, AspectJ weaver에 의해 객체들을 weaving함. 객체들을 다 불러온 뒤 weaving을 하기 때문에 약간의 퍼포먼스 하락이 있음.
  - **Run-time weaving**
    Spring AOP에서 사용하는 방식인데 소스코드나 클래스 정보 자체를 변경하지 않고 중간에 프록시 객체를 생성하여 AOP를 적용한다.

  

---

![캡처](https://user-images.githubusercontent.com/42603919/78423363-d9d9dc80-76a0-11ea-9856-7d052ca274dc.PNG)

#### Advice Type

- @Before (이전) 
  - 어드바이스 타겟 메소드가 호출되기 전에 어드바이스 기능을 수행
- @After (이후) 
  - 타겟 메소드의 결과에 관계없이(즉 성공, 예외 관계없이) 타겟 메소드가 완료 되면 어드바이스 기능을 수행
- @AfterReturning (정상적 반환 이후) 
  - 타겟 메소드가 성공적으로 결과값을 반환 후에 어드바이스 기능을 수행
- @AfterThrowing (예외 발생 이후) 
  - 타겟 메소드가 수행 중 예외를 던지게 되면 어드바이스 기능을 수행
- @Around (메소드 실행 전후) 
  - 어드바이스가 타겟 메소드를 감싸서 타겟 메소드 호출전과 후에 어드바이스 기능을 수행
  - @Around의 경우 **반드시 proceed() 메소드가 호출**되어야 한다는 것입니다. 



```java
//예를 들어 타겟 메소드의 이전 시점에서만 어드바이스 메소드를 수행하고 싶다면, 
@Before("포인트컷 표현식")
public void 어드바이스메소드() {
    ....
}
```



#### 포인트컷 지정자

- args() 
  - 메소드의 인자가 타겟 명세에 포함된 타입일 경우
  - ex) args(java.io.Serializable) : 하나의 파라미터를 갖고, 그 인자가 Serializable 타입인 모든 메소드
- @args() 
  - 메소드의 인자가 타겟 명세에 포함된 어노테이션 타입을 갖는 경우
  - ex) @args(com.blogcode.session.User) : 하나의 파라미터를 갖고, 그 인자의 타입이 @User 어노테이션을 갖는 모든 메소드 (@User User user 같이 인자 선언된 메소드)
- execution() 
  - 접근제한자, 리턴타입, 인자타입, 클래스/인터페이스, 메소드명, 파라미터타입, 예외타입 등을 전부 조합가능한 가장 세심한 지정자
  - 이전 예제와 같이 풀패키지에 메소드명까지 직접 지정할 수도 있으며, 아래와 같이 특정 타입내의 모든 메소드를 지정할 수도 있다.
  - ex) execution(* com.blogcode.service.AccountService.*(..) : AccountService 인터페이스의 모든 메소드
- within() 
  - execution 지정자에서 클래스/인터페이스까지만 적용된 경우
  - 즉, 클래스 혹은 인터페이스 단위까지만 범위 지정이 가능하다.
  - ex) within(com.blogcode.service.*) : service 패키지 아래의 클래스와 인터페이스가 가진 모든 메소드
  - ex) within(com.blogcode.service..*) : service 아래의 모든 **하위패키지까지** 포함한 클래스와 인터페이스가 가진 메소드
- @within() 
  - 주어진 어노테이션을 사용하는 타입으로 선언된 메소드
- this() 
  - 타겟 메소드가 지정된 빈 타입의 인스턴스인 경우
- target() 
  - this와 유사하지만 빈 타입이 아닌 타입의 인스턴스인 경우
- @target() 
  - 타겟 메소드를 실행하는 객체의 클래스가 타겟 명세에 지정된 타입의 어노테이션이 있는 경우
- @annotation 
  - 타겟 메소드에 특정 어노테이션이 지정된 경우
  - ex) @annotation(org.springframework.transaction.annotation.Transactional) : Transactional 어노테이션이 지정된 메소드 전부



#### AOP의 장점

- 애플리케이션 전체에 흩어진 공통 기능이 하나의 장소에서 관리된다는 점
- 다른 서비스 모듈들이 본인의 목적에만 충실하고 그 외 사항들은 신경쓰지 않아도 된다는 점